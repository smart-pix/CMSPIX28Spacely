
def interpret_CDAC_pattern_old(caplo_wave, dacclr_wave):

    #print(dacclr_waveform)

    #Assume horizontal scale of 20ns per point, and that bits are 100 ns long (75 ns + 25 ns gap)
    # (2*100 ns)/(20ns) = 10
    BIT_PERIOD = 10 #20

    #Initial offset
    idx = 3

    THRESH = 0.6
    
    binary_approximations = []
    decimal_approximations = []

    for approximation in range(1,10):

        #Find the rising edge of DACclr.
        while idx < len(caplo_wave) and not (dacclr_wave[idx-1] < THRESH and dacclr_wave[idx] > THRESH):
            idx = idx + 1


        if idx >= len(caplo_wave):
            print("ERROR (interpret_CDAC_pattern): Reached the end of the waveform w/o seeing all 10 bits. Is the Oscope resolution set properly?")
            return -99
        
        print(f"(DBG) DACclr rising edge found at: {idx}")

        #Add 2 to get off the rising edge.
        idx = idx + 3
        
        binary_approximations.append([])
                                             
        for bit in range(approximation):
            #Note the inverted polarity here b/c capLo being high means the CDAC value is decreasing.
            if caplo_wave[idx] > THRESH:
                binary_approximations[-1].append(0)
            else:
                binary_approximations[-1].append(1)
            idx = idx + BIT_PERIOD

        decimal_approximations.append(vec_to_int(binary_approximations[-1])*(2**(10-approximation)))
        print("(DBG)",binary_approximations[-1], "==",decimal_approximations[-1])
        idx = idx - BIT_PERIOD


    return decimal_approximations[-1]




#Old, do not use. 
def ROUTINE_ADC_Capture_ScanChain():
    """Operate the ADC to digitize a range of values from TestEn (DEPRECATED, DO NOT USE...)"""
    
    pr = PatternRunner(sg.log, DEFAULT_IOSPEC, DEFAULT_FPGA_BITFILE_MAP)
    gc = GlueConverter(DEFAULT_IOSPEC)
    config_AWG_as_DC(0)
    time.sleep(3)
    
    #Pre-generate patterns to run the ADC and to read from the scan chain.
    adc_op_glue = genpattern_ADC_Capture(1)
    sc_read_glue = genpattern_SC_write([0]*19,1000)
    
    
    #Set Scan Chain Configuration:  TestEn = 1  
    SC_PATTERN = SC_CFG(override=0,TestEn=1,Range2=0)
    pr.run_pattern( genpattern_SC_write(SC_PATTERN),outfile_tag="sc_cfg")
    
    #(2) Sweep ADC from 0mV to 1000mV and record the  results.
    with open("ADC_Sweep_Results.csv","w") as write_file:
        write_file.write("Vin(mV),Output Code\n")
    
        for vin in range(0,1000,100):
            #Set the input voltage:
            set_Vin_mV(vin)
            
            #Run the ADC to capture a reading.
            adc_op_result = pr.run_pattern(adc_op_glue,outfile_tag="adc_op_result")[0]
            #adc_op_result = "adc_op_result_PXI1Slot16_NI6583_se_io.glue"
            adc_bits = gc.get_clocked_bitstream(gc.read_glue(adc_op_result), "DACclr", "CompOut")
            print("CompOut value at the end of each bit period: ",adc_bits)
            x = vec_to_int(adc_bits)
            print("ADC value inferred directly from CompOut: ",x)
            
            #Scan out the result
            pr.run_pattern(sc_read_glue,outfile_tag="sc_result")
            sc_result = "sc_result_PXI1Slot16_NI6583_se_io.glue"
            scanout_bits = gc.get_clocked_bitstream(gc.read_glue(sc_result), "S_CLK", "S_DOUT")
            print("These are the bits read back from the scan chain: ", scanout_bits)
            #These bits represent the ADC result.
            x = vec_to_int(scanout_bits[0:10])
            print("ADC Reading from the Scan Chain: ",x)
            write_file.write(str(vin)+","+str(x)+"\n")

#Old, do not use.            
def ROUTINE_ADC_Capture_Scope():
    """Operate the ADC to digitize a range of values from TestEn (OSCILLOSCOPE ASSISTED)"""


    ASK_FOR_INPUT_CONNECTIONS = False

    if ASK_FOR_INPUT_CONNECTIONS:
        input("""REQUIREMENTS:
 > Oscilloscope Ch1 connected to CAPLO
 > Oscilloscope Ch2 connected to DACCLR
Press enter to continue...""")
    
    pr = PatternRunner(sg.log, DEFAULT_IOSPEC, DEFAULT_FPGA_BITFILE_MAP)
    gc = GlueConverter(DEFAULT_IOSPEC)
    config_AWG_as_DC(0)
    time.sleep(3)
    
    #Pre-generate patterns to run the ADC and to read from the scan chain.
    adc_op_glue = genpattern_ADC_Capture(10)
    sc_read_glue = genpattern_SC_write([0]*19,1000)
    
    #Set Scan Chain Configuration:  TestEn = 1  
    SC_PATTERN = SC_CFG(override=0,TestEn=1,Range2=0)
    pr.run_pattern( genpattern_SC_write(SC_PATTERN),outfile_tag="sc_cfg")
    
    #(2) Sweep ADC from 0mV to 1000mV and record the  results.
    with open("ADC_Sweep_Results.csv","w") as write_file:
        write_file.write("Vin(mV),Output Code\n")
    
        for vin in range(0,1000,10):
            
            #Set the input voltage:
            set_Vin_mV(vin)

            #Set up a 600 mV trigger on channel 1:
            sg.scope.write("HORIZONTAL:POSITION 5")  #Sets the trigger close to the left-hand side.
            sg.scope.write("HORIZONTAL:MODE MANUAL") #Manual mode: specify record length + sample rate.
            sg.scope.write("HORIZONTAL:MODE:RECORDLENGTH 10000") #RL = 10,000 ( = total pattern length of 20ns * 10k = 200 us)
            sg.scope.write("HORIZONTAL:MODE:SAMPLERATE 50E6") # = 20 ns/sample
            #sg.scope.write("HORIZONTAL:MODE:SCALE 20E-6") #Sets the horizontal resolution to 2us/div.
            #                                             #As a result we should have 20ns/sample
            sg.scope.setup_trigger(2,0.6) #600mV trigger on DACclr.
            
            #Run the ADC to capture a reading.
            pr.run_pattern(adc_op_glue,outfile_tag="adc_op_result")
            adc_op_result = "adc_op_result_PXI1Slot16_NI6583_se_io.glue"
            
            caplo_wave = sg.scope.get_wave(1)
            dacclr_wave = sg.scope.get_wave(2)

            result = interpret_CDAC_pattern_edges(caplo_wave, dacclr_wave)

            adc_bits = gc.get_clocked_bitstream(gc.read_glue(adc_op_result), "DACclr", "CompOut")
            adc_bits.reverse()
            print("CompOut value at the end of each bit period: ",adc_bits[1:])
            x = vec_to_int(adc_bits[1:])
            print("ADC value inferred directly from CompOut: ",x)

            #sg.scope.onscreen()
            write_file.write(str(vin)+","+str(result)+","+str(x)+"\n")